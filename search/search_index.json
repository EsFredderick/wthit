{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WTHIT Documentation Welcome to WTHIT documentation!","title":"WTHIT Documentation"},{"location":"#wthit-documentation","text":"Welcome to WTHIT documentation!","title":"WTHIT Documentation"},{"location":"config/blacklisting/","text":"Blacklisting Blocks and Entities To blacklist some blocks from WTHIT, create a block tag called waila:blacklist . See an entry about datapack tags on Minecraft Wiki here . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Blacklisting Blocks and Entities"},{"location":"config/blacklisting/#blacklisting-blocks-and-entities","text":"To blacklist some blocks from WTHIT, create a block tag called waila:blacklist . See an entry about datapack tags on Minecraft Wiki here . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Blacklisting Blocks and Entities"},{"location":"plugin/adding_to_blacklist/","text":"Adding to Blacklist Unlike overriding object to disable the tooltip, adding it to the blacklist means the player can override those values. You can add blocks, block entity types, and entity types to the blacklist. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addBlacklist ( Blocks . OAK_PLANKS , Blocks . CRAFTING_TABLE ) registrar . addBlacklist ( EntityType . MINECART ) } } Using tag to add to blacklist This method only viable if your mod also adds new blocks and/or entities since this would require the tag to be present on the server. Create a tag called waila:blacklist . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Adding to Blacklist"},{"location":"plugin/adding_to_blacklist/#adding-to-blacklist","text":"Unlike overriding object to disable the tooltip, adding it to the blacklist means the player can override those values. You can add blocks, block entity types, and entity types to the blacklist. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addBlacklist ( Blocks . OAK_PLANKS , Blocks . CRAFTING_TABLE ) registrar . addBlacklist ( EntityType . MINECART ) } }","title":"Adding to Blacklist"},{"location":"plugin/adding_to_blacklist/#using-tag-to-add-to-blacklist","text":"This method only viable if your mod also adds new blocks and/or entities since this would require the tag to be present on the server. Create a tag called waila:blacklist . For example, to make stone block blacklisted you make the tag contains the following data/waila/tags/blocks/blacklist.json { \"values\" : [ \"minecraft:stone\" ] } The same can be done for entity types data/waila/tags/entity_types/blacklist.json { \"values\" : [ \"minecraft:pig\" ] }","title":"Using tag to add to blacklist"},{"location":"plugin/disabling_tooltip/","text":"Disabling Tooltip Disabling Tooltip for Certain Objects Sometimes you want to disable the tooltip for showing altogether. To do that, WTHIT contains a static variable on I*ComponentProvider that we can use as a return value for getOverride . public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return EMPTY_BLOCK_STATE ; } } public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EMPTY_ENTITY ; } }","title":"Disabling Tooltip"},{"location":"plugin/disabling_tooltip/#disabling-tooltip","text":"","title":"Disabling Tooltip"},{"location":"plugin/disabling_tooltip/#disabling-tooltip-for-certain-objects","text":"Sometimes you want to disable the tooltip for showing altogether. To do that, WTHIT contains a static variable on I*ComponentProvider that we can use as a return value for getOverride . public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return EMPTY_BLOCK_STATE ; } } public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EMPTY_ENTITY ; } }","title":"Disabling Tooltip for Certain Objects"},{"location":"plugin/getting_started/","text":"Getting Started Gradle Setup To get started making a WTHIT plugin, add the following to your build.gradle Adding Repository repositories { maven { url \"https://maven.bai.lol\" } } Declaring Dependencies Fabric dependencies { // compile against the API modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\" // run against the full jar modRuntime \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" } Forge dependencies { // compile against the API compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\") // run against the full jar runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\") } Why compiling against the API jar? When you compile against the full jar and use non API classes, your mod could break any time WTHIT updates. On the other hand, the API jar is guaranteed to be stable. No breaking changes without deprecation time. If you found yourself needing to touch non API classes, open an issue on GitHub . Creating Plugins Making a Plugin Class Make a class that implements IWailaPlugin public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { // register your component here } } Registering Plugins Fabric In your fabric.mod.json add a custom value { \"waila:plugins\" : { \"id\" : \"mymod:my_plugin\" , \"initializer\" : \"foo.bar.Baz\" , } } waila:plugins can also be an array of objects instead of a singular object. A required field can be added to specify mods required for that plugin to be loaded. It can either be a single string or an array of strings. { \"waila:plugins\" : { \"id\" : \"mymod:my_plugin\" , \"initializer\" : \"foo.bar.Baz\" , \"required\" : \"mod_a\" } } Forge Annotate your plugin class with @WailaPlugin : @WailaPlugin ( id = \"mymod:waila_plugin\" ) public class MyWailaPlugin implements IWailaPlugin {} A required array can be added to specify mods required for that plugin to be loaded. @WailaPlugin ( id = \"mymod:waila_plugin\" , required = \"jei\" ) public class MyWailaPlugin implements IWailaPlugin {}","title":"Getting Started"},{"location":"plugin/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"plugin/getting_started/#gradle-setup","text":"To get started making a WTHIT plugin, add the following to your build.gradle","title":"Gradle Setup"},{"location":"plugin/getting_started/#adding-repository","text":"repositories { maven { url \"https://maven.bai.lol\" } }","title":"Adding Repository"},{"location":"plugin/getting_started/#declaring-dependencies","text":"Fabric dependencies { // compile against the API modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\" // run against the full jar modRuntime \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\" } Forge dependencies { // compile against the API compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\") // run against the full jar runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\") } Why compiling against the API jar? When you compile against the full jar and use non API classes, your mod could break any time WTHIT updates. On the other hand, the API jar is guaranteed to be stable. No breaking changes without deprecation time. If you found yourself needing to touch non API classes, open an issue on GitHub .","title":"Declaring Dependencies"},{"location":"plugin/getting_started/#creating-plugins","text":"","title":"Creating Plugins"},{"location":"plugin/getting_started/#making-a-plugin-class","text":"Make a class that implements IWailaPlugin public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { // register your component here } }","title":"Making a Plugin Class"},{"location":"plugin/getting_started/#registering-plugins","text":"Fabric In your fabric.mod.json add a custom value { \"waila:plugins\" : { \"id\" : \"mymod:my_plugin\" , \"initializer\" : \"foo.bar.Baz\" , } } waila:plugins can also be an array of objects instead of a singular object. A required field can be added to specify mods required for that plugin to be loaded. It can either be a single string or an array of strings. { \"waila:plugins\" : { \"id\" : \"mymod:my_plugin\" , \"initializer\" : \"foo.bar.Baz\" , \"required\" : \"mod_a\" } } Forge Annotate your plugin class with @WailaPlugin : @WailaPlugin ( id = \"mymod:waila_plugin\" ) public class MyWailaPlugin implements IWailaPlugin {} A required array can be added to specify mods required for that plugin to be loaded. @WailaPlugin ( id = \"mymod:waila_plugin\" , required = \"jei\" ) public class MyWailaPlugin implements IWailaPlugin {}","title":"Registering Plugins"},{"location":"plugin/overrides/","text":"Overrides If you have special blocks that shows itself as another block (example: facades), you would want that block to show the imitated block on WTHIT as well. To do that, you need to register a block override provider. Block Override In this example we wanted to show powder snow block as regular snow block. First create a class that implements IBlockComponentProvider and override the getOverride method. In there you return the block state that you want to immitate into. Yarn public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . getDefaultState (); } } Mojang public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . defaultBlockState (); } } Then you register the class on your main plugin class. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new BlockOverride (), PowderSnowBlock . class ) } } Priority WTHIT will choose the first override with lower priority number. a <= b ? a : b Entity Override It's also applicable for entities, simply make a class implementing IEntityComponentProvider public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EntityType . SHEEP . create ( accessor . getWorld ()); } } public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new EntityOverride (), PigEntity . class ) } } Caching Unlike BlockState , an Entity instance is not cached on any way. This can possibly cause performance issue if you have a many overrides. To mimimalize this, you need to cache it yourself. Since *ComponentProvider is a client-only class, caching based on world and/or position should be enough for most cases.","title":"Overrides"},{"location":"plugin/overrides/#overrides","text":"If you have special blocks that shows itself as another block (example: facades), you would want that block to show the imitated block on WTHIT as well. To do that, you need to register a block override provider.","title":"Overrides"},{"location":"plugin/overrides/#block-override","text":"In this example we wanted to show powder snow block as regular snow block. First create a class that implements IBlockComponentProvider and override the getOverride method. In there you return the block state that you want to immitate into. Yarn public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . getDefaultState (); } } Mojang public class BlockOverride implements IBlockComponentProvider { @Override public BlockState getOverride ( IBlockAccessor accessor , IPluginConfig config ) { return Blocks . SNOW_BLOCK . defaultBlockState (); } } Then you register the class on your main plugin class. public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new BlockOverride (), PowderSnowBlock . class ) } } Priority WTHIT will choose the first override with lower priority number. a <= b ? a : b","title":"Block Override"},{"location":"plugin/overrides/#entity-override","text":"It's also applicable for entities, simply make a class implementing IEntityComponentProvider public class EntityOverride implements IEntityComponentProvider { @Override public Entity getOverride ( IEntityAccessor accessor , IPluginConfig config ) { return EntityType . SHEEP . create ( accessor . getWorld ()); } } public class MyWailaPlugin implements IWailaPlugin { @Override public void register ( IRegistrar registrar ) { registrar . addOverride ( new EntityOverride (), PigEntity . class ) } } Caching Unlike BlockState , an Entity instance is not cached on any way. This can possibly cause performance issue if you have a many overrides. To mimimalize this, you need to cache it yourself. Since *ComponentProvider is a client-only class, caching based on world and/or position should be enough for most cases.","title":"Entity Override"}]}